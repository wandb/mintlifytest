{
  "openapi": "3.1.0",
  "servers": [
    {
      "url": "https://trace.wandb.ai"
    }
  ],
  "info": {
    "title": "Weave Trace Server API",
    "description": "Weave is a framework by Weights & Biases for tracking, evaluating, and monitoring LLM applications. This API provides endpoints for managing traces, objects, feedback, and costs in your AI applications.",
    "version": "0.1.0"
  },
  "paths": {
    "/server_info": {
      "get": {
        "tags": [
          "Service"
        ],
        "summary": "Get Server Information",
        "description": "Retrieve detailed information about the Weave server instance, including version, configuration, and capabilities. Use this endpoint to verify server connectivity and check available features.",
        "operationId": "server_info_server_info_get",
        "responses": {
          "200": {
            "description": "Server information retrieved successfully, including version details and configuration",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ServerInfoRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid request parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/health": {
      "get": {
        "tags": [
          "Service"
        ],
        "summary": "Health Check",
        "description": "Check the health status of the Weave server. Returns a simple response indicating whether the server is operational. Use this endpoint for monitoring and load balancer health checks.",
        "operationId": "read_root_health_get",
        "responses": {
          "200": {
            "description": "Server is healthy and operational",
            "content": {
              "application/json": {
                "schema": {
                  "additionalProperties": {
                    "type": "string"
                  },
                  "type": "object",
                  "title": "Response Read Root Health Get"
                }
              }
            }
          },
          "422": {
            "description": "Invalid request parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/call/start": {
      "post": {
        "tags": [
          "Calls"
        ],
        "summary": "Start a Call Trace",
        "description": "Begin tracking a new call in your LLM application. This creates a trace entry that captures the start of a function execution, LLM invocation, or any operation you want to monitor. Each call is assigned a unique ID and can be nested within parent calls to create a trace hierarchy.",
        "operationId": "call_start_call_start_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CallStartReq"
              }
            }
          },
          "required": true,
          "description": "Call initialization details including operation name, inputs, and optional parent trace ID"
        },
        "responses": {
          "200": {
            "description": "Call trace started successfully. Returns the unique call ID for tracking.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CallStartRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid request body or parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/call/end": {
      "post": {
        "tags": [
          "Calls"
        ],
        "summary": "End a Call Trace",
        "description": "Complete a previously started call trace. This captures the output, duration, and any errors that occurred during execution. Always pair this with a corresponding call/start to ensure complete trace data.",
        "operationId": "call_end_call_end_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CallEndReq"
              }
            }
          },
          "required": true,
          "description": "Call completion details including outputs, errors, and final status"
        },
        "responses": {
          "200": {
            "description": "Call trace ended successfully. The trace is now complete with timing and output data.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CallEndRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid request body or call ID not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/call/upsert_batch": {
      "post": {
        "tags": [
          "Calls"
        ],
        "summary": "Batch Create or Update Calls",
        "description": "Efficiently create or update multiple call traces in a single request. Ideal for bulk imports, offline processing, or when you need to log multiple completed traces at once. Each call in the batch can represent a complete trace with start and end information.",
        "operationId": "call_start_batch_call_upsert_batch_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CallCreateBatchReq"
              }
            }
          },
          "required": true,
          "description": "Array of call traces to create or update"
        },
        "responses": {
          "200": {
            "description": "Batch operation completed successfully. Returns status for each call in the batch.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CallCreateBatchRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid batch data or request format",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/calls/delete": {
      "post": {
        "tags": [
          "Calls"
        ],
        "summary": "Delete Call Traces",
        "description": "Permanently remove one or more call traces from Weave. Use with caution as this operation cannot be undone. Useful for data cleanup, privacy compliance, or removing test data.",
        "operationId": "calls_delete_calls_delete_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CallsDeleteReq"
              }
            }
          },
          "required": true,
          "description": "Specify which calls to delete by ID or filter criteria"
        },
        "responses": {
          "200": {
            "description": "Calls deleted successfully. Returns count of deleted traces.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CallsDeleteRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid deletion criteria or request format",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/call/update": {
      "post": {
        "tags": [
          "Calls"
        ],
        "summary": "Update Call Trace",
        "description": "Modify an existing call trace to add or update metadata, attributes, or outputs. Useful for adding annotations, correcting data, or appending additional information after the initial trace.",
        "operationId": "call_update_call_update_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CallUpdateReq"
              }
            }
          },
          "required": true,
          "description": "Call ID and fields to update"
        },
        "responses": {
          "200": {
            "description": "Call updated successfully with new information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CallUpdateRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid update data or call not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/call/read": {
      "post": {
        "tags": [
          "Calls"
        ],
        "summary": "Read Call Details",
        "description": "Retrieve complete information about a specific call trace, including inputs, outputs, timing, errors, and any associated metadata. Use this to inspect individual traces in detail.",
        "operationId": "call_read_call_read_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CallReadReq"
              }
            }
          },
          "required": true,
          "description": "Call ID to retrieve"
        },
        "responses": {
          "200": {
            "description": "Call details retrieved successfully with complete trace information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CallReadRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid call ID or request format",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/calls/query_stats": {
      "post": {
        "tags": [
          "Calls"
        ],
        "summary": "Query Call Statistics",
        "description": "Aggregate and analyze call traces to get statistical insights. Returns metrics like call counts, average duration, error rates, and token usage statistics. Essential for monitoring application performance and identifying optimization opportunities.",
        "operationId": "calls_query_stats_calls_query_stats_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CallsQueryStatsReq"
              }
            }
          },
          "required": true,
          "description": "Query filters and aggregation parameters"
        },
        "responses": {
          "200": {
            "description": "Statistics calculated successfully with aggregated metrics",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CallsQueryStatsRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid query parameters or aggregation options",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/calls/stream_query": {
      "post": {
        "tags": [
          "Calls"
        ],
        "summary": "Stream Call Query Results",
        "description": "Execute a query for call traces and stream the results in JSONL format. Ideal for processing large datasets, real-time monitoring, or when you need to handle results incrementally. Supports complex filtering and sorting.",
        "operationId": "calls_query_stream_calls_stream_query_post",
        "security": [
          {
            "HTTPBasic": []
          }
        ],
        "parameters": [
          {
            "name": "accept",
            "in": "header",
            "required": false,
            "schema": {
              "type": "string",
              "default": "application/jsonl",
              "title": "Accept"
            },
            "description": "Response format - use application/jsonl for streaming"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CallsQueryReq"
              }
            }
          },
          "description": "Query filters, sorting, and pagination options"
        },
        "responses": {
          "200": {
            "description": "Streaming response with one JSON object per line representing each matching call",
            "content": {
              "application/jsonl": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/Schema"
                  }
                }
              }
            }
          },
          "422": {
            "description": "Invalid query parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/obj/create": {
      "post": {
        "tags": [
          "Objects"
        ],
        "summary": "Create Weave Object",
        "description": "Store a versioned object in Weave, such as a model, dataset, or prompt. Objects are automatically versioned and can be referenced across your application. Use this to track artifacts and ensure reproducibility.",
        "operationId": "obj_create_obj_create_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ObjCreateReq"
              }
            }
          },
          "required": true,
          "description": "Object data including name, type, and content"
        },
        "responses": {
          "200": {
            "description": "Object created successfully with unique ID and version",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjCreateRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid object data or schema validation error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/obj/read": {
      "post": {
        "tags": [
          "Objects"
        ],
        "summary": "Read Weave Object",
        "description": "Retrieve a specific version of a Weave object by its ID. Returns the complete object data including metadata and content. Use version specifiers to access historical versions.",
        "operationId": "obj_read_obj_read_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ObjReadReq"
              }
            }
          },
          "required": true,
          "description": "Object ID and optional version specifier"
        },
        "responses": {
          "200": {
            "description": "Object retrieved successfully with complete data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjReadRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid object ID or version not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/objs/query": {
      "post": {
        "tags": [
          "Objects"
        ],
        "summary": "Query Weave Objects",
        "description": "Search and filter Weave objects based on type, name, metadata, or other criteria. Supports pagination and sorting to efficiently browse large object collections.",
        "operationId": "objs_query_objs_query_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ObjQueryReq"
              }
            }
          },
          "required": true,
          "description": "Query filters and pagination parameters"
        },
        "responses": {
          "200": {
            "description": "Query results with matching objects and pagination info",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjQueryRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid query parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/obj/delete": {
      "post": {
        "tags": [
          "Objects"
        ],
        "summary": "Delete Weave Object",
        "description": "Remove a Weave object and all its versions. This operation is permanent and cannot be undone. Use with caution, especially for objects referenced by other parts of your application.",
        "operationId": "obj_delete_obj_delete_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ObjDeleteReq"
              }
            }
          },
          "required": true,
          "description": "Object ID to delete"
        },
        "responses": {
          "200": {
            "description": "Object deleted successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjDeleteRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid object ID or object not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/table/create": {
      "post": {
        "tags": [
          "Tables"
        ],
        "summary": "Create Table",
        "description": "Create a new table object in Weave for storing structured data like evaluation results, datasets, or metrics. Tables support efficient querying and are ideal for tabular data analysis.",
        "operationId": "table_create_table_create_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TableCreateReq"
              }
            }
          },
          "required": true,
          "description": "Table schema and initial data"
        },
        "responses": {
          "200": {
            "description": "Table created successfully with unique identifier",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TableCreateRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid table schema or data format",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/table/update": {
      "post": {
        "tags": [
          "Tables"
        ],
        "summary": "Update Table",
        "description": "Modify an existing table by adding, updating, or removing rows. Supports bulk operations for efficient data management. Changes are versioned automatically.",
        "operationId": "table_update_table_update_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TableUpdateReq"
              }
            }
          },
          "required": true,
          "description": "Table ID and update operations"
        },
        "responses": {
          "200": {
            "description": "Table updated successfully with operation summary",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TableUpdateRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid update operations or table not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/table/query": {
      "post": {
        "tags": [
          "Tables"
        ],
        "summary": "Query Table Data",
        "description": "Execute queries against table data with filtering, sorting, and aggregation capabilities. Supports complex queries for data analysis and reporting.",
        "operationId": "table_query_table_query_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TableQueryReq"
              }
            }
          },
          "required": true,
          "description": "Query parameters including filters and projections"
        },
        "responses": {
          "200": {
            "description": "Query results with matching rows and metadata",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TableQueryRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid query syntax or parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/table/query_stream": {
      "post": {
        "summary": "Stream Table Query Results",
        "description": "Execute a table query and stream results in JSONL format for efficient processing of large datasets. Each row is returned as a separate JSON object, allowing incremental processing.",
        "operationId": "table_query_stream_table_query_stream_post",
        "security": [
          {
            "HTTPBasic": []
          }
        ],
        "parameters": [
          {
            "name": "accept",
            "in": "header",
            "required": false,
            "schema": {
              "type": "string",
              "default": "application/jsonl",
              "title": "Accept"
            },
            "description": "Response format for streaming results"
          }
        ],
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TableQueryReq"
              }
            }
          },
          "description": "Table query with streaming enabled"
        },
        "responses": {
          "200": {
            "description": "Streaming response with one table row per line in JSONL format",
            "content": {
              "application/jsonl": {
                "schema": {
                  "type": "string"
                }
              }
            }
          },
          "422": {
            "description": "Invalid query parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        }
      }
    },
    "/table/query_stats": {
      "post": {
        "tags": [
          "Tables"
        ],
        "summary": "Query Table Statistics",
        "description": "Get statistical summaries of table data including counts, averages, distributions, and other aggregate metrics. Useful for data quality checks and exploratory analysis.",
        "operationId": "table_query_stats_table_query_stats_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TableQueryStatsReq"
              }
            }
          },
          "required": true,
          "description": "Statistics query parameters and aggregations"
        },
        "responses": {
          "200": {
            "description": "Table statistics calculated successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TableQueryStatsRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid statistics query",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/refs/read_batch": {
      "post": {
        "tags": [
          "References"
        ],
        "summary": "Batch Read References",
        "description": "Efficiently resolve multiple Weave references in a single request. References can point to objects, tables, or other resources. This endpoint optimizes performance when loading multiple related items.",
        "operationId": "refs_read_batch_refs_read_batch_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/RefsReadBatchReq"
              }
            }
          },
          "required": true,
          "description": "List of references to resolve"
        },
        "responses": {
          "200": {
            "description": "References resolved successfully with their corresponding data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/RefsReadBatchRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid reference format or references not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/file/create": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Upload File",
        "description": "Upload a file to Weave storage for use with objects, datasets, or artifacts. Files are content-addressed and deduplicated automatically. Supports various file types including models, images, and data files.",
        "operationId": "file_create_file_create_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FileCreateReq"
              }
            }
          },
          "required": true,
          "description": "File metadata and content"
        },
        "responses": {
          "200": {
            "description": "File uploaded successfully with unique digest for reference",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FileCreateRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid file data or upload error",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/file/content": {
      "post": {
        "tags": [
          "Files"
        ],
        "summary": "Download File Content",
        "description": "Retrieve the binary content of a previously uploaded file using its digest. Returns the raw file data for download or processing.",
        "operationId": "file_content_file_content_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FileContentReq"
              }
            }
          },
          "required": true,
          "description": "File digest to retrieve"
        },
        "responses": {
          "200": {
            "description": "File content retrieved successfully as binary stream",
            "content": {
              "application/octet-stream": {
                "schema": {
                  "type": "string",
                  "format": "binary"
                }
              }
            }
          },
          "422": {
            "description": "Invalid file digest or file not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/cost/create": {
      "post": {
        "tags": [
          "Costs"
        ],
        "summary": "Create Cost Entry",
        "description": "Record LLM usage costs for tracking and analysis. Automatically associates costs with specific calls when call_id is provided. Supports custom pricing models and multiple currency units.",
        "operationId": "cost_create_cost_create_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CostCreateReq"
              }
            }
          },
          "required": true,
          "description": "Cost details including tokens, pricing, and associated call"
        },
        "responses": {
          "200": {
            "description": "Cost entry created successfully for tracking",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CostCreateRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid cost data or pricing information",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/cost/query": {
      "post": {
        "tags": [
          "Costs"
        ],
        "summary": "Query Cost Data",
        "description": "Analyze LLM usage costs with filtering and aggregation options. Get insights into spending patterns, model usage, and cost trends over time. Supports grouping by model, time period, or custom dimensions.",
        "operationId": "cost_query_cost_query_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CostQueryReq"
              }
            }
          },
          "required": true,
          "description": "Cost query filters and aggregation options"
        },
        "responses": {
          "200": {
            "description": "Cost analysis results with aggregated metrics",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CostQueryRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid query parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/cost/purge": {
      "post": {
        "tags": [
          "Costs"
        ],
        "summary": "Purge Cost Data",
        "description": "Remove cost entries based on specified criteria. Useful for data cleanup, removing test data, or complying with data retention policies. This operation is permanent.",
        "operationId": "cost_purge_cost_purge_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CostPurgeReq"
              }
            }
          },
          "required": true,
          "description": "Criteria for selecting costs to purge"
        },
        "responses": {
          "200": {
            "description": "Cost data purged successfully with count of removed entries",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CostPurgeRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid purge criteria",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/feedback/create": {
      "post": {
        "tags": [
          "Feedback"
        ],
        "summary": "Create Feedback",
        "description": "Add human or automated feedback to calls or objects. Feedback can include ratings, corrections, or annotations. Essential for improving model performance through human-in-the-loop workflows.",
        "operationId": "feedback_create_feedback_create_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FeedbackCreateReq"
              }
            }
          },
          "required": true,
          "description": "Feedback details including type, value, and target"
        },
        "responses": {
          "200": {
            "description": "Feedback created and associated with the target successfully",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeedbackCreateRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid feedback data or target not found",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/feedback/query": {
      "post": {
        "tags": [
          "Feedback"
        ],
        "summary": "Query Feedback",
        "description": "Search and analyze feedback data with filtering options. Retrieve feedback by type, creator, time range, or associated object. Useful for evaluation workflows and quality monitoring.",
        "operationId": "feedback_query_feedback_query_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FeedbackQueryReq"
              }
            }
          },
          "required": true,
          "description": "Feedback query filters and pagination"
        },
        "responses": {
          "200": {
            "description": "Feedback query results with matching entries",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeedbackQueryRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid query parameters",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/feedback/purge": {
      "post": {
        "tags": [
          "Feedback"
        ],
        "summary": "Purge Feedback",
        "description": "Permanently delete feedback entries based on specified criteria. Use for data cleanup, removing outdated feedback, or managing data retention. This operation cannot be undone.",
        "operationId": "feedback_purge_feedback_purge_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FeedbackPurgeReq"
              }
            }
          },
          "required": true,
          "description": "Criteria for selecting feedback to delete"
        },
        "responses": {
          "200": {
            "description": "Feedback purged successfully with deletion count",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeedbackPurgeRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid purge criteria",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    },
    "/feedback/replace": {
      "post": {
        "tags": [
          "Feedback"
        ],
        "summary": "Replace Feedback",
        "description": "Update or replace existing feedback entries. Maintains feedback history while allowing corrections or updates to ratings and annotations. Useful for refining human feedback over time.",
        "operationId": "feedback_replace_feedback_replace_post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/FeedbackReplaceReq"
              }
            }
          },
          "required": true,
          "description": "Feedback ID and replacement data"
        },
        "responses": {
          "200": {
            "description": "Feedback replaced successfully with version tracking",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/FeedbackReplaceRes"
                }
              }
            }
          },
          "422": {
            "description": "Invalid feedback ID or replacement data",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/HTTPValidationError"
                }
              }
            }
          }
        },
        "security": [
          {
            "HTTPBasic": []
          }
        ]
      }
    }
  }
}